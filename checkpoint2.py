# -*- coding: utf-8 -*-
"""checkpoint2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UHBILNCViG-MtTyU4iyZBniEONkRxweI
"""

import pandas as pd
import numpy as np
from ydata_profiling import ProfileReport
import matplotlib.pyplot as plt
import joblib
import seaborn as sns
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from imblearn.over_sampling import SMOTE
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

df=pd.read_csv("Financial_inclusion_dataset.csv")
df.head()

df.info()

df.describe()
profile = ProfileReport(df, title='Profiling Report', explorative=True)
profile.to_file("profiling_rep.html")
df.isnull().sum()

df.duplicated().sum()

df = df.drop('uniqueid', axis=1).copy()

label_encoder = LabelEncoder()
df['bank_account_encoded'] = label_encoder.fit_transform(df['bank_account'])
categorical_cols = [
    'country', 'location_type', 'cellphone_access', 'gender_of_respondent',
    'relationship_with_head', 'marital_status', 'education_level', 'job_type'
]
for col in categorical_cols:
    df[col] = label_encoder.fit_transform(df[col])
df.head()

numerical_cols = ['year', 'household_size', 'age_of_respondent']
scaler = StandardScaler()
df[numerical_cols] = scaler.fit_transform(df[numerical_cols])
df.describe()

col_num = df.select_dtypes(include=np.number).columns
col_num

cols_to_plot = ['household_size','age_of_respondent','marital_status','education_level']
n_rows = 2
n_cols_plot = 2
plt.figure(figsize=(25, 25))
plt.suptitle('Distribution des Caractéristiques Numériques APRES RobustScaler', fontsize=20, y=1.00)
for i, col in enumerate(cols_to_plot):
    plt.subplot(n_rows, n_cols_plot, i + 1)
    sns.boxplot(y=df[col])
    plt.title(f'{col}', fontsize=12)
    plt.ylabel(None)
    plt.xlabel(None)
    plt.yticks(fontsize=10)
    plt.grid(True, axis='y', linestyle='--', alpha=0.5)
plt.tight_layout(rect=[0, 0.03, 1, 0.98])
plt.show()

for col in cols_to_plot:
    Q1 = df[col].quantile(0.25)
    Q3 = df[col].quantile(0.75)
    IQR = Q3 - Q1
    borne_inf = max(0.0, Q1 - 1.5 * IQR)
    borne_sup = Q3 + 1.5 * IQR
    df[col] = df[col].clip(lower=borne_inf, upper=borne_sup)

cols_to_plot = ['household_size','age_of_respondent','marital_status','education_level']
n_rows = 2
n_cols_plot = 2
plt.figure(figsize=(25, 25))
plt.suptitle('Distribution des Caractéristiques Numériques APRES RobustScaler', fontsize=20, y=1.00)
for i, col in enumerate(cols_to_plot):
    plt.subplot(n_rows, n_cols_plot, i + 1)
    sns.boxplot(y=df[col])
    plt.title(f'{col}', fontsize=12)
    plt.ylabel(None)
    plt.xlabel(None)
    plt.yticks(fontsize=10)
    plt.grid(True, axis='y', linestyle='--', alpha=0.5)
plt.tight_layout(rect=[0, 0.03, 1, 0.98])
plt.show()

df.hist(bins=10,figsize=(10,10))
plt.show()



# Drop the original 'bank_account' column as we have the encoded version 'bank_account_encoded'
df_model = df.drop('bank_account', axis=1).copy()

# Define features (X) and target (y)
X = df_model.drop('bank_account_encoded', axis=1)
y = df_model['bank_account_encoded']

print("Features (X) shape:", X.shape)
print("Target (y) shape:", y.shape)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

print("X_train shape:", X_train.shape)
print("X_test shape:", X_test.shape)
print("y_train shape:", y_train.shape)
print("y_test shape:", y_test.shape)

# Initialize and train a RandomForestClassifier model
model = RandomForestClassifier(n_estimators=100, random_state=42, class_weight='balanced')
model.fit(X_train, y_train)

print("Random Forest Classifier trained successfully.")

# Make predictions on the test set
y_pred = model.predict(X_test)

# Evaluate the model
accuracy = accuracy_score(y_test, y_pred)
report = classification_report(y_test, y_pred)
conf_matrix = confusion_matrix(y_test, y_pred)

print(f"Accuracy: {accuracy:.4f}")
print("\nClassification Report:\n", report)
print("\nConfusion Matrix:\n", conf_matrix)

# Visualize the confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues',
            xticklabels=['No Bank Account', 'Has Bank Account'],
            yticklabels=['No Bank Account', 'Has Bank Account'])
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()

sm = SMOTE(random_state=42)
X_train_res, y_train_res = sm.fit_resample(X_train, y_train)

model_resampled = RandomForestClassifier(n_estimators=100, random_state=42, class_weight='balanced')
model_resampled.fit(X_train_res, y_train_res)

y_pred_resampled = model_resampled.predict(X_test)

accuracy_resampled = accuracy_score(y_test, y_pred_resampled)
report_resampled = classification_report(y_test, y_pred_resampled)
conf_matrix_resampled = confusion_matrix(y_test, y_pred_resampled)
print(f"Accuracy (Resampled Model): {accuracy_resampled:.4f}")
print("\nClassification Report (Resampled Model):\n", report_resampled)
print("\nConfusion Matrix (Resampled Model):\n", conf_matrix_resampled)
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix_resampled, annot=True, fmt='d', cmap='Blues',
            xticklabels=['No Bank Account', 'Has Bank Account'],
            yticklabels=['No Bank Account', 'Has Bank Account'])
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix (Resampled Model)')
plt.show()
joblib.dump(model_resampled, 'model.pkl')
# Sauvegarder le scaler (indispensable pour les données utilisateur)
joblib.dump(scaler, 'scaler.pkl')
# Sauvegarder le label_encoder (optionnel, mais utile pour décoder les résultats)
joblib.dump(label_encoder, 'label_encoder.pkl')